// CSV Importer Example
//
// This example demonstrates how to programmatically build Beancount transactions
// from CSV bank statement data using the ast builder functions.
//
// Usage:
//
//	go run main.go transactions.csv
package main

import (
	"encoding/csv"
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/robinvdvleuten/beancount/ast"
	"github.com/robinvdvleuten/beancount/formatter"
)

// CSVRecord represents a single row from the bank statement CSV
type CSVRecord struct {
	Date   string
	Payee  string
	Amount string
}

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s <csv-file>\n", os.Args[0])
		os.Exit(1)
	}

	filename := os.Args[1]

	// Read and parse CSV file
	records, err := readCSV(filename)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading CSV: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("; Imported from %s\n", filename)
	fmt.Println("; Generated by csv_importer example")
	fmt.Println()

	// Create formatter
	fmtr := formatter.New()

	// Convert each CSV record to a Beancount transaction
	for i, record := range records {
		txn, err := recordToTransaction(record)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error on row %d: %v\n", i+2, err) // +2 for header and 1-indexing
			continue
		}

		// Format and print the transaction
		if err := fmtr.FormatTransaction(txn, os.Stdout); err != nil {
			fmt.Fprintf(os.Stderr, "Error formatting transaction: %v\n", err)
			continue
		}
		fmt.Println()
	}
}

// readCSV reads a CSV file and returns the parsed records
func readCSV(filename string) ([]CSVRecord, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to open file: %w", err)
	}
	defer func() { _ = file.Close() }()

	reader := csv.NewReader(file)
	reader.TrimLeadingSpace = true

	// Read all records
	rows, err := reader.ReadAll()
	if err != nil {
		return nil, fmt.Errorf("failed to parse CSV: %w", err)
	}

	if len(rows) < 2 {
		return nil, fmt.Errorf("CSV file is empty or missing header")
	}

	// Validate header
	header := rows[0]
	if len(header) < 3 {
		return nil, fmt.Errorf("CSV header must have at least 3 columns: Date,Payee,Amount")
	}

	// Parse data rows
	var records []CSVRecord
	for _, row := range rows[1:] {
		if len(row) < 3 {
			continue // Skip incomplete rows
		}
		records = append(records, CSVRecord{
			Date:   row[0],
			Payee:  row[1],
			Amount: row[2],
		})
	}

	return records, nil
}

// recordToTransaction converts a CSV record into a Beancount transaction
func recordToTransaction(record CSVRecord) (*ast.Transaction, error) {
	// Parse and validate date
	date, err := ast.NewDate(record.Date)
	if err != nil {
		return nil, fmt.Errorf("invalid date %q: %w", record.Date, err)
	}

	// Parse amount
	amount, err := strconv.ParseFloat(record.Amount, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid amount %q: %w", record.Amount, err)
	}

	// Categorize the transaction and create postings
	var postings []*ast.Posting
	var category string

	checkingAccount, _ := ast.NewAccount("Assets:Checking")

	if amount < 0 {
		// Expense: money leaving the account
		absAmount := fmt.Sprintf("%.2f", -amount)
		category = categorizeExpense(record.Payee)
		expenseAccount, err := ast.NewAccount(category)
		if err != nil {
			return nil, fmt.Errorf("invalid expense account: %w", err)
		}

		// Debit expense category, credit checking account
		postings = []*ast.Posting{
			ast.NewPosting(expenseAccount, ast.WithAmount(absAmount, "USD")),
			ast.NewPosting(checkingAccount),
		}
	} else {
		// Income: money entering the account
		amountStr := fmt.Sprintf("%.2f", amount)
		category = categorizeIncome(record.Payee)
		incomeAccount, err := ast.NewAccount(category)
		if err != nil {
			return nil, fmt.Errorf("invalid income account: %w", err)
		}

		// Debit checking account, credit income category
		postings = []*ast.Posting{
			ast.NewPosting(checkingAccount, ast.WithAmount(amountStr, "USD")),
			ast.NewPosting(incomeAccount),
		}
	}

	// Build the transaction using functional options pattern
	txn := ast.NewTransaction(date, record.Payee,
		ast.WithFlag("*"), // Cleared transaction
		ast.WithPostings(postings...),
	)

	return txn, nil
}

// categorizeExpense categorizes an expense based on the payee name
func categorizeExpense(payee string) string {
	payeeLower := strings.ToLower(payee)

	// Simple keyword-based categorization
	switch {
	case strings.Contains(payeeLower, "whole foods"),
		strings.Contains(payeeLower, "safeway"),
		strings.Contains(payeeLower, "trader joe"),
		strings.Contains(payeeLower, "grocery"):
		return "Expenses:Groceries"

	case strings.Contains(payeeLower, "restaurant"),
		strings.Contains(payeeLower, "cafe"),
		strings.Contains(payeeLower, "pizza"),
		strings.Contains(payeeLower, "burger"):
		return "Expenses:Dining"

	case strings.Contains(payeeLower, "uber"),
		strings.Contains(payeeLower, "lyft"),
		strings.Contains(payeeLower, "transit"),
		strings.Contains(payeeLower, "metro"):
		return "Expenses:Transport"

	case strings.Contains(payeeLower, "electric"),
		strings.Contains(payeeLower, "gas"),
		strings.Contains(payeeLower, "water"),
		strings.Contains(payeeLower, "internet"),
		strings.Contains(payeeLower, "utility"):
		return "Expenses:Utilities"

	case strings.Contains(payeeLower, "rent"),
		strings.Contains(payeeLower, "mortgage"):
		return "Expenses:Rent"

	default:
		return "Expenses:Other"
	}
}

// categorizeIncome categorizes income based on the payee name
func categorizeIncome(payee string) string {
	payeeLower := strings.ToLower(payee)

	switch {
	case strings.Contains(payeeLower, "salary"),
		strings.Contains(payeeLower, "payroll"),
		strings.Contains(payeeLower, "employer"):
		return "Income:Salary"

	case strings.Contains(payeeLower, "interest"),
		strings.Contains(payeeLower, "dividend"):
		return "Income:Investment"

	default:
		return "Income:Other"
	}
}
