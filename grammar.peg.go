package beancount

// Code generated by peg -inline -switch grammar.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleBeancount
	ruleDirective
	ruleOpen
	ruleClose
	ruleCommodity
	ruleTransaction
	rulePosting
	ruleOption
	ruleInclude
	ruleComment
	ruleMetadata
	ruleAccount
	ruleCurrency
	ruleDate
	ruleFlag
	ruleNumber
	rule_
	ruleWhitespace
	ruleEOL
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
)

var rul3s = [...]string{
	"Unknown",
	"Beancount",
	"Directive",
	"Open",
	"Close",
	"Commodity",
	"Transaction",
	"Posting",
	"Option",
	"Include",
	"Comment",
	"Metadata",
	"Account",
	"Currency",
	"Date",
	"Flag",
	"Number",
	"_",
	"Whitespace",
	"EOL",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type parser struct {
	a *AST
	d Directive
	m *Metadata
	o *Option
	p *Posting
	i *Include

	Buffer string
	buffer []rune
	rules  [60]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *parser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *parser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *parser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *parser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *parser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *parser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *parser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.d = &Open{BookingMethod: "STRICT"}
			p.a.Directives = append(p.a.Directives, p.d)
		case ruleAction1:
			p.d.(*Open).Date = text
		case ruleAction2:
			p.d.(*Open).Account = text
		case ruleAction3:
			p.d.(*Open).ConstraintCurrencies = strings.Split(strings.ReplaceAll(text, " ", ""), ",")
		case ruleAction4:
			p.d.(*Open).BookingMethod = text
		case ruleAction5:
			p.d.AddMetadata(p.m)
		case ruleAction6:
			p.d = &Close{}
			p.a.Directives = append(p.a.Directives, p.d)
		case ruleAction7:
			p.d.(*Close).Date = text
		case ruleAction8:
			p.d.(*Close).Account = text
		case ruleAction9:
			p.d.AddMetadata(p.m)
		case ruleAction10:
			p.d = &Commodity{}
			p.a.Directives = append(p.a.Directives, p.d)
		case ruleAction11:
			p.d.(*Commodity).Date = text
		case ruleAction12:
			p.d.(*Commodity).Currency = text
		case ruleAction13:
			p.d.AddMetadata(p.m)
		case ruleAction14:
			p.d = &Transaction{Flag: "*"}
			p.a.Directives = append(p.a.Directives, p.d)
		case ruleAction15:
			p.d.(*Transaction).Date = text
		case ruleAction16:
			p.d.(*Transaction).Flag = text
		case ruleAction17:
			p.d.(*Transaction).Payee = text
		case ruleAction18:
			p.d.(*Transaction).Narration = text
		case ruleAction19:
			p.d.AddMetadata(p.m)
		case ruleAction20:
			p.p = &Posting{Flag: p.d.(*Transaction).Flag}
			p.d.(*Transaction).Postings = append(p.d.(*Transaction).Postings, p.p)
		case ruleAction21:
			p.p.Flag = text
		case ruleAction22:
			p.p.Account = text
		case ruleAction23:
			p.p.Amount = &Amount{Value: text}
		case ruleAction24:
			p.p.Amount.Currency = text
		case ruleAction25:
			p.p.Cost = &Amount{Value: text}
		case ruleAction26:
			p.p.Cost.Currency = text
		case ruleAction27:
			p.p.Price = &Price{Total: text == "@@"}
		case ruleAction28:
			p.p.Price.Value = text
		case ruleAction29:
			p.p.Price.Currency = text
		case ruleAction30:
			p.p.AddMetadata(p.m)
		case ruleAction31:
			p.o = &Option{}
			p.a.Options = append(p.a.Options, p.o)
		case ruleAction32:
			p.o.Name = text
		case ruleAction33:
			p.o.Value = text
		case ruleAction34:
			p.i = &Include{}
			p.a.Includes = append(p.a.Includes, p.i)
		case ruleAction35:
			p.i.Filename = text
		case ruleAction36:
			p.m = &Metadata{}
		case ruleAction37:
			p.m.Key = text
		case ruleAction38:
			p.m.Value = text

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*parser) error {
	return func(p *parser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*parser) error {
	return func(p *parser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *parser) Init(options ...func(*parser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Beancount <- <(Comment / Directive / Option / Include / .)*> */
		func() bool {
			{
				position1 := position
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[ruleComment]() {
							goto l5
						}
						goto l4
					l5:
						position, tokenIndex = position4, tokenIndex4
						{
							position7 := position
							{
								position8, tokenIndex8 := position, tokenIndex
								{
									position10 := position
									{
										add(ruleAction0, position)
									}
									{
										position12 := position
										if !_rules[ruleDate]() {
											goto l9
										}
										add(rulePegText, position12)
									}
									if buffer[position] != rune(' ') {
										goto l9
									}
									position++
									if buffer[position] != rune('o') {
										goto l9
									}
									position++
									if buffer[position] != rune('p') {
										goto l9
									}
									position++
									if buffer[position] != rune('e') {
										goto l9
									}
									position++
									if buffer[position] != rune('n') {
										goto l9
									}
									position++
									{
										add(ruleAction1, position)
									}
									if !_rules[rule_]() {
										goto l9
									}
									{
										position14 := position
										if !_rules[ruleAccount]() {
											goto l9
										}
										add(rulePegText, position14)
									}
									{
										add(ruleAction2, position)
									}
									if !_rules[rule_]() {
										goto l9
									}
									{
										position16 := position
										if !_rules[ruleCurrency]() {
											goto l9
										}
									l17:
										{
											position18, tokenIndex18 := position, tokenIndex
											if buffer[position] != rune(',') {
												goto l18
											}
											position++
											{
												position19, tokenIndex19 := position, tokenIndex
												if buffer[position] != rune(' ') {
													goto l19
												}
												position++
												goto l20
											l19:
												position, tokenIndex = position19, tokenIndex19
											}
										l20:
											if !_rules[ruleCurrency]() {
												goto l18
											}
											goto l17
										l18:
											position, tokenIndex = position18, tokenIndex18
										}
										add(rulePegText, position16)
									}
									{
										add(ruleAction3, position)
									}
									{
										position22, tokenIndex22 := position, tokenIndex
										if !_rules[rule_]() {
											goto l22
										}
										{
											position24 := position
											{
												position25, tokenIndex25 := position, tokenIndex
												if buffer[position] != rune('S') {
													goto l26
												}
												position++
												if buffer[position] != rune('T') {
													goto l26
												}
												position++
												if buffer[position] != rune('R') {
													goto l26
												}
												position++
												if buffer[position] != rune('I') {
													goto l26
												}
												position++
												if buffer[position] != rune('C') {
													goto l26
												}
												position++
												if buffer[position] != rune('T') {
													goto l26
												}
												position++
												goto l25
											l26:
												position, tokenIndex = position25, tokenIndex25
												if buffer[position] != rune('N') {
													goto l22
												}
												position++
												if buffer[position] != rune('O') {
													goto l22
												}
												position++
												if buffer[position] != rune('N') {
													goto l22
												}
												position++
												if buffer[position] != rune('E') {
													goto l22
												}
												position++
											}
										l25:
											add(rulePegText, position24)
										}
										{
											add(ruleAction4, position)
										}
										goto l23
									l22:
										position, tokenIndex = position22, tokenIndex22
									}
								l23:
									if !_rules[rule_]() {
										goto l9
									}
									{
										position28, tokenIndex28 := position, tokenIndex
										if !_rules[ruleComment]() {
											goto l28
										}
										goto l29
									l28:
										position, tokenIndex = position28, tokenIndex28
									}
								l29:
									if !_rules[rule_]() {
										goto l9
									}
								l30:
									{
										position31, tokenIndex31 := position, tokenIndex
										if !_rules[ruleMetadata]() {
											goto l31
										}
										{
											add(ruleAction5, position)
										}
										goto l30
									l31:
										position, tokenIndex = position31, tokenIndex31
									}
									if !_rules[rule_]() {
										goto l9
									}
									add(ruleOpen, position10)
								}
								goto l8
							l9:
								position, tokenIndex = position8, tokenIndex8
								{
									position34 := position
									{
										add(ruleAction6, position)
									}
									{
										position36 := position
										if !_rules[ruleDate]() {
											goto l33
										}
										add(rulePegText, position36)
									}
									if buffer[position] != rune(' ') {
										goto l33
									}
									position++
									if buffer[position] != rune('c') {
										goto l33
									}
									position++
									if buffer[position] != rune('l') {
										goto l33
									}
									position++
									if buffer[position] != rune('o') {
										goto l33
									}
									position++
									if buffer[position] != rune('s') {
										goto l33
									}
									position++
									if buffer[position] != rune('e') {
										goto l33
									}
									position++
									{
										add(ruleAction7, position)
									}
									if !_rules[rule_]() {
										goto l33
									}
									{
										position38 := position
										if !_rules[ruleAccount]() {
											goto l33
										}
										add(rulePegText, position38)
									}
									{
										add(ruleAction8, position)
									}
									if !_rules[rule_]() {
										goto l33
									}
									{
										position40, tokenIndex40 := position, tokenIndex
										if !_rules[ruleComment]() {
											goto l40
										}
										goto l41
									l40:
										position, tokenIndex = position40, tokenIndex40
									}
								l41:
									if !_rules[rule_]() {
										goto l33
									}
								l42:
									{
										position43, tokenIndex43 := position, tokenIndex
										if !_rules[ruleMetadata]() {
											goto l43
										}
										{
											add(ruleAction9, position)
										}
										goto l42
									l43:
										position, tokenIndex = position43, tokenIndex43
									}
									if !_rules[rule_]() {
										goto l33
									}
									add(ruleClose, position34)
								}
								goto l8
							l33:
								position, tokenIndex = position8, tokenIndex8
								{
									position46 := position
									{
										add(ruleAction10, position)
									}
									{
										position48 := position
										if !_rules[ruleDate]() {
											goto l45
										}
										add(rulePegText, position48)
									}
									{
										add(ruleAction11, position)
									}
									if !_rules[rule_]() {
										goto l45
									}
									if buffer[position] != rune('c') {
										goto l45
									}
									position++
									if buffer[position] != rune('o') {
										goto l45
									}
									position++
									if buffer[position] != rune('m') {
										goto l45
									}
									position++
									if buffer[position] != rune('m') {
										goto l45
									}
									position++
									if buffer[position] != rune('o') {
										goto l45
									}
									position++
									if buffer[position] != rune('d') {
										goto l45
									}
									position++
									if buffer[position] != rune('i') {
										goto l45
									}
									position++
									if buffer[position] != rune('t') {
										goto l45
									}
									position++
									if buffer[position] != rune('y') {
										goto l45
									}
									position++
									if !_rules[rule_]() {
										goto l45
									}
									{
										position50 := position
										if !_rules[ruleCurrency]() {
											goto l45
										}
										add(rulePegText, position50)
									}
									{
										add(ruleAction12, position)
									}
									if !_rules[rule_]() {
										goto l45
									}
									{
										position52, tokenIndex52 := position, tokenIndex
										if !_rules[ruleComment]() {
											goto l52
										}
										goto l53
									l52:
										position, tokenIndex = position52, tokenIndex52
									}
								l53:
									if !_rules[rule_]() {
										goto l45
									}
								l54:
									{
										position55, tokenIndex55 := position, tokenIndex
										if !_rules[ruleMetadata]() {
											goto l55
										}
										{
											add(ruleAction13, position)
										}
										goto l54
									l55:
										position, tokenIndex = position55, tokenIndex55
									}
									if !_rules[rule_]() {
										goto l45
									}
									add(ruleCommodity, position46)
								}
								goto l8
							l45:
								position, tokenIndex = position8, tokenIndex8
								{
									position57 := position
									{
										add(ruleAction14, position)
									}
									{
										position59 := position
										if !_rules[ruleDate]() {
											goto l6
										}
										add(rulePegText, position59)
									}
									{
										add(ruleAction15, position)
									}
									if buffer[position] != rune(' ') {
										goto l6
									}
									position++
									{
										position61, tokenIndex61 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l62
										}
										position++
										if buffer[position] != rune('x') {
											goto l62
										}
										position++
										if buffer[position] != rune('n') {
											goto l62
										}
										position++
										goto l61
									l62:
										position, tokenIndex = position61, tokenIndex61
										{
											position63 := position
											if !_rules[ruleFlag]() {
												goto l6
											}
											add(rulePegText, position63)
										}
										{
											add(ruleAction16, position)
										}
									}
								l61:
									{
										position65, tokenIndex65 := position, tokenIndex
										if buffer[position] != rune(' ') {
											goto l65
										}
										position++
										if buffer[position] != rune('"') {
											goto l65
										}
										position++
										{
											position67 := position
											{
												position70, tokenIndex70 := position, tokenIndex
												if buffer[position] != rune('"') {
													goto l70
												}
												position++
												goto l65
											l70:
												position, tokenIndex = position70, tokenIndex70
											}
											if !matchDot() {
												goto l65
											}
										l68:
											{
												position69, tokenIndex69 := position, tokenIndex
												{
													position71, tokenIndex71 := position, tokenIndex
													if buffer[position] != rune('"') {
														goto l71
													}
													position++
													goto l69
												l71:
													position, tokenIndex = position71, tokenIndex71
												}
												if !matchDot() {
													goto l69
												}
												goto l68
											l69:
												position, tokenIndex = position69, tokenIndex69
											}
											add(rulePegText, position67)
										}
										if buffer[position] != rune('"') {
											goto l65
										}
										position++
										{
											position72, tokenIndex72 := position, tokenIndex
											if buffer[position] != rune(' ') {
												goto l65
											}
											position++
											if buffer[position] != rune('"') {
												goto l65
											}
											position++
											position, tokenIndex = position72, tokenIndex72
										}
										{
											add(ruleAction17, position)
										}
										goto l66
									l65:
										position, tokenIndex = position65, tokenIndex65
									}
								l66:
									{
										position74, tokenIndex74 := position, tokenIndex
										if buffer[position] != rune(' ') {
											goto l74
										}
										position++
										if buffer[position] != rune('"') {
											goto l74
										}
										position++
										{
											position76 := position
											{
												position79, tokenIndex79 := position, tokenIndex
												if buffer[position] != rune('"') {
													goto l79
												}
												position++
												goto l74
											l79:
												position, tokenIndex = position79, tokenIndex79
											}
											if !matchDot() {
												goto l74
											}
										l77:
											{
												position78, tokenIndex78 := position, tokenIndex
												{
													position80, tokenIndex80 := position, tokenIndex
													if buffer[position] != rune('"') {
														goto l80
													}
													position++
													goto l78
												l80:
													position, tokenIndex = position80, tokenIndex80
												}
												if !matchDot() {
													goto l78
												}
												goto l77
											l78:
												position, tokenIndex = position78, tokenIndex78
											}
											add(rulePegText, position76)
										}
										if buffer[position] != rune('"') {
											goto l74
										}
										position++
										{
											add(ruleAction18, position)
										}
										goto l75
									l74:
										position, tokenIndex = position74, tokenIndex74
									}
								l75:
									if !_rules[rule_]() {
										goto l6
									}
									{
										position82, tokenIndex82 := position, tokenIndex
										if !_rules[ruleComment]() {
											goto l82
										}
										goto l83
									l82:
										position, tokenIndex = position82, tokenIndex82
									}
								l83:
									if !_rules[rule_]() {
										goto l6
									}
								l84:
									{
										position85, tokenIndex85 := position, tokenIndex
										if !_rules[ruleMetadata]() {
											goto l85
										}
										{
											add(ruleAction19, position)
										}
										goto l84
									l85:
										position, tokenIndex = position85, tokenIndex85
									}
									if !_rules[rule_]() {
										goto l6
									}
								l87:
									{
										position88, tokenIndex88 := position, tokenIndex
										{
											position89 := position
											{
												add(ruleAction20, position)
											}
											{
												position91, tokenIndex91 := position, tokenIndex
												{
													position93 := position
													if !_rules[ruleFlag]() {
														goto l91
													}
													add(rulePegText, position93)
												}
												{
													add(ruleAction21, position)
												}
												goto l92
											l91:
												position, tokenIndex = position91, tokenIndex91
											}
										l92:
											if !_rules[rule_]() {
												goto l88
											}
											{
												position95 := position
												if !_rules[ruleAccount]() {
													goto l88
												}
												add(rulePegText, position95)
											}
											{
												add(ruleAction22, position)
											}
											{
												position97, tokenIndex97 := position, tokenIndex
												if !_rules[rule_]() {
													goto l97
												}
												{
													position99 := position
													if !_rules[ruleNumber]() {
														goto l97
													}
													add(rulePegText, position99)
												}
												{
													add(ruleAction23, position)
												}
												if !_rules[rule_]() {
													goto l97
												}
												{
													position101 := position
													if !_rules[ruleCurrency]() {
														goto l97
													}
													add(rulePegText, position101)
												}
												{
													add(ruleAction24, position)
												}
												goto l98
											l97:
												position, tokenIndex = position97, tokenIndex97
											}
										l98:
											{
												position103, tokenIndex103 := position, tokenIndex
												if !_rules[rule_]() {
													goto l103
												}
												if buffer[position] != rune('{') {
													goto l103
												}
												position++
												if !_rules[rule_]() {
													goto l103
												}
												{
													position105 := position
													if !_rules[ruleNumber]() {
														goto l103
													}
													add(rulePegText, position105)
												}
												{
													add(ruleAction25, position)
												}
												if !_rules[rule_]() {
													goto l103
												}
												{
													position107 := position
													if !_rules[ruleCurrency]() {
														goto l103
													}
													add(rulePegText, position107)
												}
												{
													add(ruleAction26, position)
												}
												if !_rules[rule_]() {
													goto l103
												}
												if buffer[position] != rune('}') {
													goto l103
												}
												position++
												goto l104
											l103:
												position, tokenIndex = position103, tokenIndex103
											}
										l104:
											{
												position109, tokenIndex109 := position, tokenIndex
												if !_rules[rule_]() {
													goto l109
												}
												{
													position111 := position
													if buffer[position] != rune('@') {
														goto l109
													}
													position++
													{
														position112, tokenIndex112 := position, tokenIndex
														if buffer[position] != rune('@') {
															goto l112
														}
														position++
														goto l113
													l112:
														position, tokenIndex = position112, tokenIndex112
													}
												l113:
													add(rulePegText, position111)
												}
												{
													add(ruleAction27, position)
												}
												if !_rules[rule_]() {
													goto l109
												}
												{
													position115 := position
													if !_rules[ruleNumber]() {
														goto l109
													}
													add(rulePegText, position115)
												}
												{
													add(ruleAction28, position)
												}
												if !_rules[rule_]() {
													goto l109
												}
												{
													position117 := position
													if !_rules[ruleCurrency]() {
														goto l109
													}
													add(rulePegText, position117)
												}
												{
													add(ruleAction29, position)
												}
												goto l110
											l109:
												position, tokenIndex = position109, tokenIndex109
											}
										l110:
											if !_rules[rule_]() {
												goto l88
											}
											{
												position119, tokenIndex119 := position, tokenIndex
												if !_rules[ruleComment]() {
													goto l119
												}
												goto l120
											l119:
												position, tokenIndex = position119, tokenIndex119
											}
										l120:
											if !_rules[rule_]() {
												goto l88
											}
										l121:
											{
												position122, tokenIndex122 := position, tokenIndex
												if !_rules[ruleMetadata]() {
													goto l122
												}
												{
													add(ruleAction30, position)
												}
												goto l121
											l122:
												position, tokenIndex = position122, tokenIndex122
											}
											if !_rules[rule_]() {
												goto l88
											}
											add(rulePosting, position89)
										}
										goto l87
									l88:
										position, tokenIndex = position88, tokenIndex88
									}
									if !_rules[rule_]() {
										goto l6
									}
									add(ruleTransaction, position57)
								}
							}
						l8:
							add(ruleDirective, position7)
						}
						goto l4
					l6:
						position, tokenIndex = position4, tokenIndex4
						{
							position125 := position
							if buffer[position] != rune('o') {
								goto l124
							}
							position++
							if buffer[position] != rune('p') {
								goto l124
							}
							position++
							if buffer[position] != rune('t') {
								goto l124
							}
							position++
							if buffer[position] != rune('i') {
								goto l124
							}
							position++
							if buffer[position] != rune('o') {
								goto l124
							}
							position++
							if buffer[position] != rune('n') {
								goto l124
							}
							position++
							{
								add(ruleAction31, position)
							}
							if buffer[position] != rune(' ') {
								goto l124
							}
							position++
							if buffer[position] != rune('"') {
								goto l124
							}
							position++
							{
								position127 := position
								{
									position130, tokenIndex130 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l130
									}
									position++
									goto l124
								l130:
									position, tokenIndex = position130, tokenIndex130
								}
								if !matchDot() {
									goto l124
								}
							l128:
								{
									position129, tokenIndex129 := position, tokenIndex
									{
										position131, tokenIndex131 := position, tokenIndex
										if buffer[position] != rune('"') {
											goto l131
										}
										position++
										goto l129
									l131:
										position, tokenIndex = position131, tokenIndex131
									}
									if !matchDot() {
										goto l129
									}
									goto l128
								l129:
									position, tokenIndex = position129, tokenIndex129
								}
								add(rulePegText, position127)
							}
							if buffer[position] != rune('"') {
								goto l124
							}
							position++
							{
								add(ruleAction32, position)
							}
							if buffer[position] != rune(' ') {
								goto l124
							}
							position++
							if buffer[position] != rune('"') {
								goto l124
							}
							position++
							{
								position133 := position
								{
									position136, tokenIndex136 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l136
									}
									position++
									goto l124
								l136:
									position, tokenIndex = position136, tokenIndex136
								}
								if !matchDot() {
									goto l124
								}
							l134:
								{
									position135, tokenIndex135 := position, tokenIndex
									{
										position137, tokenIndex137 := position, tokenIndex
										if buffer[position] != rune('"') {
											goto l137
										}
										position++
										goto l135
									l137:
										position, tokenIndex = position137, tokenIndex137
									}
									if !matchDot() {
										goto l135
									}
									goto l134
								l135:
									position, tokenIndex = position135, tokenIndex135
								}
								add(rulePegText, position133)
							}
							if buffer[position] != rune('"') {
								goto l124
							}
							position++
							{
								add(ruleAction33, position)
							}
							if !_rules[rule_]() {
								goto l124
							}
							{
								position139, tokenIndex139 := position, tokenIndex
								if !_rules[ruleComment]() {
									goto l139
								}
								goto l140
							l139:
								position, tokenIndex = position139, tokenIndex139
							}
						l140:
							if !_rules[rule_]() {
								goto l124
							}
							add(ruleOption, position125)
						}
						goto l4
					l124:
						position, tokenIndex = position4, tokenIndex4
						{
							position142 := position
							if buffer[position] != rune('i') {
								goto l141
							}
							position++
							if buffer[position] != rune('n') {
								goto l141
							}
							position++
							if buffer[position] != rune('c') {
								goto l141
							}
							position++
							if buffer[position] != rune('l') {
								goto l141
							}
							position++
							if buffer[position] != rune('u') {
								goto l141
							}
							position++
							if buffer[position] != rune('d') {
								goto l141
							}
							position++
							if buffer[position] != rune('e') {
								goto l141
							}
							position++
							{
								add(ruleAction34, position)
							}
							if buffer[position] != rune(' ') {
								goto l141
							}
							position++
							if buffer[position] != rune('"') {
								goto l141
							}
							position++
							{
								position144 := position
								{
									position147, tokenIndex147 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l147
									}
									position++
									goto l141
								l147:
									position, tokenIndex = position147, tokenIndex147
								}
								if !matchDot() {
									goto l141
								}
							l145:
								{
									position146, tokenIndex146 := position, tokenIndex
									{
										position148, tokenIndex148 := position, tokenIndex
										if buffer[position] != rune('"') {
											goto l148
										}
										position++
										goto l146
									l148:
										position, tokenIndex = position148, tokenIndex148
									}
									if !matchDot() {
										goto l146
									}
									goto l145
								l146:
									position, tokenIndex = position146, tokenIndex146
								}
								add(rulePegText, position144)
							}
							if buffer[position] != rune('"') {
								goto l141
							}
							position++
							{
								add(ruleAction35, position)
							}
							if !_rules[rule_]() {
								goto l141
							}
							add(ruleInclude, position142)
						}
						goto l4
					l141:
						position, tokenIndex = position4, tokenIndex4
						if !matchDot() {
							goto l3
						}
					}
				l4:
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				add(ruleBeancount, position1)
			}
			return true
		},
		/* 1 Directive <- <(Open / Close / Commodity / Transaction)> */
		nil,
		/* 2 Open <- <(Action0 <Date> ' ' ('o' 'p' 'e' 'n') Action1 _ <Account> Action2 _ <(Currency (',' ' '? Currency)*)> Action3 (_ <(('S' 'T' 'R' 'I' 'C' 'T') / ('N' 'O' 'N' 'E'))> Action4)? _ Comment? _ (Metadata Action5)* _)> */
		nil,
		/* 3 Close <- <(Action6 <Date> ' ' ('c' 'l' 'o' 's' 'e') Action7 _ <Account> Action8 _ Comment? _ (Metadata Action9)* _)> */
		nil,
		/* 4 Commodity <- <(Action10 <Date> Action11 _ ('c' 'o' 'm' 'm' 'o' 'd' 'i' 't' 'y') _ <Currency> Action12 _ Comment? _ (Metadata Action13)* _)> */
		nil,
		/* 5 Transaction <- <(Action14 <Date> Action15 ' ' (('t' 'x' 'n') / (<Flag> Action16)) (' ' '"' <(!'"' .)+> '"' &(' ' '"') Action17)? (' ' '"' <(!'"' .)+> '"' Action18)? _ Comment? _ (Metadata Action19)* _ Posting* _)> */
		nil,
		/* 6 Posting <- <(Action20 (<Flag> Action21)? _ <Account> Action22 (_ <Number> Action23 _ <Currency> Action24)? (_ '{' _ <Number> Action25 _ <Currency> Action26 _ '}')? (_ <('@' '@'?)> Action27 _ <Number> Action28 _ <Currency> Action29)? _ Comment? _ (Metadata Action30)* _)> */
		nil,
		/* 7 Option <- <('o' 'p' 't' 'i' 'o' 'n' Action31 ' ' '"' <(!'"' .)+> '"' Action32 ' ' '"' <(!'"' .)+> '"' Action33 _ Comment? _)> */
		nil,
		/* 8 Include <- <('i' 'n' 'c' 'l' 'u' 'd' 'e' Action34 ' ' '"' <(!'"' .)+> '"' Action35 _)> */
		nil,
		/* 9 Comment <- <(';' (!EOL .)* EOL)> */
		func() bool {
			position158, tokenIndex158 := position, tokenIndex
			{
				position159 := position
				if buffer[position] != rune(';') {
					goto l158
				}
				position++
			l160:
				{
					position161, tokenIndex161 := position, tokenIndex
					{
						position162, tokenIndex162 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l162
						}
						goto l161
					l162:
						position, tokenIndex = position162, tokenIndex162
					}
					if !matchDot() {
						goto l161
					}
					goto l160
				l161:
					position, tokenIndex = position161, tokenIndex161
				}
				if !_rules[ruleEOL]() {
					goto l158
				}
				add(ruleComment, position159)
			}
			return true
		l158:
			position, tokenIndex = position158, tokenIndex158
			return false
		},
		/* 10 Metadata <- <(Action36 <([a-z]+ ((&('_') '_') | (&('-') '-') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))*)> Action37 ':' _ '"' <(!'"' .)+> '"' Action38 _)> */
		func() bool {
			position163, tokenIndex163 := position, tokenIndex
			{
				position164 := position
				{
					add(ruleAction36, position)
				}
				{
					position166 := position
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l163
					}
					position++
				l167:
					{
						position168, tokenIndex168 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l168
						}
						position++
						goto l167
					l168:
						position, tokenIndex = position168, tokenIndex168
					}
				l169:
					{
						position170, tokenIndex170 := position, tokenIndex
						{
							switch buffer[position] {
							case '_':
								if buffer[position] != rune('_') {
									goto l170
								}
								position++
							case '-':
								if buffer[position] != rune('-') {
									goto l170
								}
								position++
							case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l170
								}
								position++
							case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
								if c := buffer[position]; c < rune('A') || c > rune('Z') {
									goto l170
								}
								position++
							default:
								if c := buffer[position]; c < rune('a') || c > rune('z') {
									goto l170
								}
								position++
							}
						}

						goto l169
					l170:
						position, tokenIndex = position170, tokenIndex170
					}
					add(rulePegText, position166)
				}
				{
					add(ruleAction37, position)
				}
				if buffer[position] != rune(':') {
					goto l163
				}
				position++
				if !_rules[rule_]() {
					goto l163
				}
				if buffer[position] != rune('"') {
					goto l163
				}
				position++
				{
					position173 := position
					{
						position176, tokenIndex176 := position, tokenIndex
						if buffer[position] != rune('"') {
							goto l176
						}
						position++
						goto l163
					l176:
						position, tokenIndex = position176, tokenIndex176
					}
					if !matchDot() {
						goto l163
					}
				l174:
					{
						position175, tokenIndex175 := position, tokenIndex
						{
							position177, tokenIndex177 := position, tokenIndex
							if buffer[position] != rune('"') {
								goto l177
							}
							position++
							goto l175
						l177:
							position, tokenIndex = position177, tokenIndex177
						}
						if !matchDot() {
							goto l175
						}
						goto l174
					l175:
						position, tokenIndex = position175, tokenIndex175
					}
					add(rulePegText, position173)
				}
				if buffer[position] != rune('"') {
					goto l163
				}
				position++
				{
					add(ruleAction38, position)
				}
				if !_rules[rule_]() {
					goto l163
				}
				add(ruleMetadata, position164)
			}
			return true
		l163:
			position, tokenIndex = position163, tokenIndex163
			return false
		},
		/* 11 Account <- <([A-Z] ([a-z] / [A-Z])* (':' ([a-z] / [A-Z])+ ('-' ([a-z] / [A-Z])+)?)*)> */
		func() bool {
			position179, tokenIndex179 := position, tokenIndex
			{
				position180 := position
				if c := buffer[position]; c < rune('A') || c > rune('Z') {
					goto l179
				}
				position++
			l181:
				{
					position182, tokenIndex182 := position, tokenIndex
					{
						position183, tokenIndex183 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l184
						}
						position++
						goto l183
					l184:
						position, tokenIndex = position183, tokenIndex183
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l182
						}
						position++
					}
				l183:
					goto l181
				l182:
					position, tokenIndex = position182, tokenIndex182
				}
			l185:
				{
					position186, tokenIndex186 := position, tokenIndex
					if buffer[position] != rune(':') {
						goto l186
					}
					position++
					{
						position189, tokenIndex189 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l190
						}
						position++
						goto l189
					l190:
						position, tokenIndex = position189, tokenIndex189
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l186
						}
						position++
					}
				l189:
				l187:
					{
						position188, tokenIndex188 := position, tokenIndex
						{
							position191, tokenIndex191 := position, tokenIndex
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l192
							}
							position++
							goto l191
						l192:
							position, tokenIndex = position191, tokenIndex191
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l188
							}
							position++
						}
					l191:
						goto l187
					l188:
						position, tokenIndex = position188, tokenIndex188
					}
					{
						position193, tokenIndex193 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l193
						}
						position++
						{
							position197, tokenIndex197 := position, tokenIndex
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l198
							}
							position++
							goto l197
						l198:
							position, tokenIndex = position197, tokenIndex197
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l193
							}
							position++
						}
					l197:
					l195:
						{
							position196, tokenIndex196 := position, tokenIndex
							{
								position199, tokenIndex199 := position, tokenIndex
								if c := buffer[position]; c < rune('a') || c > rune('z') {
									goto l200
								}
								position++
								goto l199
							l200:
								position, tokenIndex = position199, tokenIndex199
								if c := buffer[position]; c < rune('A') || c > rune('Z') {
									goto l196
								}
								position++
							}
						l199:
							goto l195
						l196:
							position, tokenIndex = position196, tokenIndex196
						}
						goto l194
					l193:
						position, tokenIndex = position193, tokenIndex193
					}
				l194:
					goto l185
				l186:
					position, tokenIndex = position186, tokenIndex186
				}
				add(ruleAccount, position180)
			}
			return true
		l179:
			position, tokenIndex = position179, tokenIndex179
			return false
		},
		/* 12 Currency <- <[A-Z]+> */
		func() bool {
			position201, tokenIndex201 := position, tokenIndex
			{
				position202 := position
				if c := buffer[position]; c < rune('A') || c > rune('Z') {
					goto l201
				}
				position++
			l203:
				{
					position204, tokenIndex204 := position, tokenIndex
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l204
					}
					position++
					goto l203
				l204:
					position, tokenIndex = position204, tokenIndex204
				}
				add(ruleCurrency, position202)
			}
			return true
		l201:
			position, tokenIndex = position201, tokenIndex201
			return false
		},
		/* 13 Date <- <([0-9] [0-9] [0-9] [0-9] '-' [0-9] [0-9] '-' [0-9] [0-9])> */
		func() bool {
			position205, tokenIndex205 := position, tokenIndex
			{
				position206 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l205
				}
				position++
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l205
				}
				position++
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l205
				}
				position++
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l205
				}
				position++
				if buffer[position] != rune('-') {
					goto l205
				}
				position++
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l205
				}
				position++
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l205
				}
				position++
				if buffer[position] != rune('-') {
					goto l205
				}
				position++
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l205
				}
				position++
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l205
				}
				position++
				add(ruleDate, position206)
			}
			return true
		l205:
			position, tokenIndex = position205, tokenIndex205
			return false
		},
		/* 14 Flag <- <('*' / '!')> */
		func() bool {
			position207, tokenIndex207 := position, tokenIndex
			{
				position208 := position
				{
					position209, tokenIndex209 := position, tokenIndex
					if buffer[position] != rune('*') {
						goto l210
					}
					position++
					goto l209
				l210:
					position, tokenIndex = position209, tokenIndex209
					if buffer[position] != rune('!') {
						goto l207
					}
					position++
				}
			l209:
				add(ruleFlag, position208)
			}
			return true
		l207:
			position, tokenIndex = position207, tokenIndex207
			return false
		},
		/* 15 Number <- <(('+' / '-')? ([0-9]* '.')? [0-9]+)> */
		func() bool {
			position211, tokenIndex211 := position, tokenIndex
			{
				position212 := position
				{
					position213, tokenIndex213 := position, tokenIndex
					{
						position215, tokenIndex215 := position, tokenIndex
						if buffer[position] != rune('+') {
							goto l216
						}
						position++
						goto l215
					l216:
						position, tokenIndex = position215, tokenIndex215
						if buffer[position] != rune('-') {
							goto l213
						}
						position++
					}
				l215:
					goto l214
				l213:
					position, tokenIndex = position213, tokenIndex213
				}
			l214:
				{
					position217, tokenIndex217 := position, tokenIndex
				l219:
					{
						position220, tokenIndex220 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l220
						}
						position++
						goto l219
					l220:
						position, tokenIndex = position220, tokenIndex220
					}
					if buffer[position] != rune('.') {
						goto l217
					}
					position++
					goto l218
				l217:
					position, tokenIndex = position217, tokenIndex217
				}
			l218:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l211
				}
				position++
			l221:
				{
					position222, tokenIndex222 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l222
					}
					position++
					goto l221
				l222:
					position, tokenIndex = position222, tokenIndex222
				}
				add(ruleNumber, position212)
			}
			return true
		l211:
			position, tokenIndex = position211, tokenIndex211
			return false
		},
		/* 16 _ <- <Whitespace*> */
		func() bool {
			{
				position224 := position
			l225:
				{
					position226, tokenIndex226 := position, tokenIndex
					{
						position227 := position
						{
							switch buffer[position] {
							case '\n':
								if !_rules[ruleEOL]() {
									goto l226
								}
							case '\t':
								if buffer[position] != rune('\t') {
									goto l226
								}
								position++
							default:
								if buffer[position] != rune(' ') {
									goto l226
								}
								position++
							}
						}

						add(ruleWhitespace, position227)
					}
					goto l225
				l226:
					position, tokenIndex = position226, tokenIndex226
				}
				add(rule_, position224)
			}
			return true
		},
		/* 17 Whitespace <- <((&('\n') EOL) | (&('\t') '\t') | (&(' ') ' '))> */
		nil,
		/* 18 EOL <- <'\n'> */
		func() bool {
			position230, tokenIndex230 := position, tokenIndex
			{
				position231 := position
				if buffer[position] != rune('\n') {
					goto l230
				}
				position++
				add(ruleEOL, position231)
			}
			return true
		l230:
			position, tokenIndex = position230, tokenIndex230
			return false
		},
		/* 20 Action0 <- <{ p.d = &Open{BookingMethod: "STRICT"}; p.a.Directives = append(p.a.Directives, p.d) }> */
		nil,
		nil,
		/* 22 Action1 <- <{ p.d.(*Open).Date = text }> */
		nil,
		/* 23 Action2 <- <{ p.d.(*Open).Account = text }> */
		nil,
		/* 24 Action3 <- <{ p.d.(*Open).ConstraintCurrencies = strings.Split(strings.ReplaceAll(text, " ", ""), ",") }> */
		nil,
		/* 25 Action4 <- <{ p.d.(*Open).BookingMethod = text }> */
		nil,
		/* 26 Action5 <- <{ p.d.AddMetadata(p.m) }> */
		nil,
		/* 27 Action6 <- <{ p.d = &Close{}; p.a.Directives = append(p.a.Directives, p.d) }> */
		nil,
		/* 28 Action7 <- <{ p.d.(*Close).Date = text }> */
		nil,
		/* 29 Action8 <- <{ p.d.(*Close).Account = text }> */
		nil,
		/* 30 Action9 <- <{ p.d.AddMetadata(p.m) }> */
		nil,
		/* 31 Action10 <- <{ p.d = &Commodity{}; p.a.Directives = append(p.a.Directives, p.d) }> */
		nil,
		/* 32 Action11 <- <{ p.d.(*Commodity).Date = text }> */
		nil,
		/* 33 Action12 <- <{ p.d.(*Commodity).Currency = text }> */
		nil,
		/* 34 Action13 <- <{ p.d.AddMetadata(p.m) }> */
		nil,
		/* 35 Action14 <- <{ p.d = &Transaction{Flag: "*"}; p.a.Directives = append(p.a.Directives, p.d) }> */
		nil,
		/* 36 Action15 <- <{ p.d.(*Transaction).Date = text }> */
		nil,
		/* 37 Action16 <- <{ p.d.(*Transaction).Flag = text }> */
		nil,
		/* 38 Action17 <- <{ p.d.(*Transaction).Payee = text }> */
		nil,
		/* 39 Action18 <- <{ p.d.(*Transaction).Narration = text }> */
		nil,
		/* 40 Action19 <- <{ p.d.AddMetadata(p.m) }> */
		nil,
		/* 41 Action20 <- <{ p.p = &Posting{Flag: p.d.(*Transaction).Flag}; p.d.(*Transaction).Postings = append(p.d.(*Transaction).Postings, p.p) }> */
		nil,
		/* 42 Action21 <- <{ p.p.Flag = text }> */
		nil,
		/* 43 Action22 <- <{ p.p.Account = text }> */
		nil,
		/* 44 Action23 <- <{ p.p.Amount = &Amount{Value: text} }> */
		nil,
		/* 45 Action24 <- <{ p.p.Amount.Currency = text }> */
		nil,
		/* 46 Action25 <- <{ p.p.Cost = &Amount{Value: text} }> */
		nil,
		/* 47 Action26 <- <{ p.p.Cost.Currency = text }> */
		nil,
		/* 48 Action27 <- <{ p.p.Price = &Price{Total: text == "@@"} }> */
		nil,
		/* 49 Action28 <- <{ p.p.Price.Value = text }> */
		nil,
		/* 50 Action29 <- <{ p.p.Price.Currency = text }> */
		nil,
		/* 51 Action30 <- <{ p.p.AddMetadata(p.m) }> */
		nil,
		/* 52 Action31 <- <{ p.o = &Option{}; p.a.Options = append(p.a.Options, p.o) }> */
		nil,
		/* 53 Action32 <- <{ p.o.Name = text }> */
		nil,
		/* 54 Action33 <- <{ p.o.Value = text }> */
		nil,
		/* 55 Action34 <- <{ p.i = &Include{}; p.a.Includes = append(p.a.Includes, p.i) }> */
		nil,
		/* 56 Action35 <- <{ p.i.Filename = text }> */
		nil,
		/* 57 Action36 <- <{ p.m = &Metadata{}; }> */
		nil,
		/* 58 Action37 <- <{ p.m.Key = text }> */
		nil,
		/* 59 Action38 <- <{ p.m.Value = text }> */
		nil,
	}
	p.rules = _rules
	return nil
}
